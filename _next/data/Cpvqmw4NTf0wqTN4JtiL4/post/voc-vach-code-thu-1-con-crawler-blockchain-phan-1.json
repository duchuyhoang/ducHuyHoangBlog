{"pageProps":{"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      img: \"img\",\n      h2: \"h2\",\n      a: \"a\",\n      ul: \"ul\",\n      li: \"li\",\n      hr: \"hr\",\n      code: \"code\",\n      h3: \"h3\",\n      pre: \"pre\"\n    }, _provideComponents(), props.components), {FullSizeImage} = _components;\n    if (!FullSizeImage) _missingMdxReference(\"FullSizeImage\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"blockchain-crawler/bg.jpeg\",\n          alt: \"'vs_code'\"\n        })\n      }), \"\\n\", _jsx(\"p\", {\n        class: \"mt-3 mb-3\",\n        children: _jsx(_components.p, {\n          children: \"Lần này mình sẽ giới thiệu đến các bạn về 1 con crawler event của blockchain\\nmà mình tự viết . Các bạn có gì góp ý đóng góp thì cứ tự nhiên để lại comment\\nnha\"\n        })\n      }), \"\\n\", _jsxs(\"div\", {\n        id: \"blockchainCrawlerMenu\",\n        children: [_jsxs(_components.h2, {\n          children: [_jsx(_components.a, {\n            href: \"#blockchainCrawlerMenu\",\n            children: _jsx(\"img\", {\n              src: \"hashtag.svg\",\n              width: \"20px\",\n              height: \"20px\"\n            })\n          }), \" Mục lục\"]\n        }), _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.a, {\n              href: \"#blockchainCrawlerCore\",\n              children: \"Core concepts\"\n            }), \"\\n\", _jsxs(_components.ul, {\n              children: [\"\\n\", _jsxs(_components.li, {\n                children: [_jsx(_components.a, {\n                  href: \"#blockchainCrawlerOverview\",\n                  children: \"Tổng quan\"\n                }), \"\\n\", _jsxs(_components.ul, {\n                  children: [\"\\n\", _jsx(_components.li, {\n                    children: _jsx(_components.a, {\n                      href: \"#blockchainCrawlerDb\",\n                      children: \"Thiết kế database\"\n                    })\n                  }), \"\\n\", _jsx(_components.li, {\n                    children: _jsx(_components.a, {\n                      href: \"#blockchainTech\",\n                      children: \"Công nghệ sử dụng\"\n                    })\n                  }), \"\\n\", _jsxs(_components.li, {\n                    children: [_jsx(_components.a, {\n                      href: \"#blockchainCrawlerBaseClass\",\n                      children: \"Các base class trong ứng dụng\"\n                    }), \"\\n\", _jsxs(_components.ul, {\n                      children: [\"\\n\", _jsx(_components.li, {\n                        children: _jsx(_components.a, {\n                          href: \"#blockchainCrawlerIntervalWorker\",\n                          children: \"BaseIntevalWorker\"\n                        })\n                      }), \"\\n\", _jsx(_components.li, {\n                        children: _jsx(_components.a, {\n                          href: \"#blockchainCrawlerEventCrawler\",\n                          children: \"BaseEventCrawler\"\n                        })\n                      }), \"\\n\", _jsx(_components.li, {\n                        children: _jsx(_components.a, {\n                          href: \"#blockchainCrawlerProcessor\",\n                          children: \"Processor\"\n                        })\n                      }), \"\\n\", _jsx(_components.li, {\n                        children: _jsx(_components.a, {\n                          href: \"#blockchainLauncher\",\n                          children: \"BaseLauncher\"\n                        })\n                      }), \"\\n\"]\n                    }), \"\\n\"]\n                  }), \"\\n\"]\n                }), \"\\n\"]\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsx(_components.li, {\n            children: _jsx(_components.a, {\n              href: \"#blockchainCrawlerSummary\",\n              children: \"Tổng kết\"\n            })\n          }), \"\\n\"]\n        }), _jsx(_components.hr, {})]\n      }), \"\\n\", _jsx(\"div\", {\n        id: \"blockchainCrawlerCore\",\n        children: _jsxs(\"article\", {\n          id: \"blockchainCrawlerOverview\",\n          children: [_jsxs(_components.h2, {\n            children: [_jsx(_components.a, {\n              href: \"#blockchainCrawlerOverview\",\n              children: _jsx(\"img\", {\n                src: \"hashtag.svg\",\n                width: \"20px\",\n                height: \"20px\"\n              })\n            }), \" Tổng quan\"]\n          }), _jsx(_components.p, {\n            children: \"Trước hết thì mình sẽ nói về cách hoạt động của con crawler. Nó là 1 chương trình nodejs chạy 1 worker interval để crawl theo từng block mới đc thêm vào trên 1 mạng blockchain qua đó thực hiên các action update owner của nft, list nft lên sàn, hay stop listing nft trên sàn.\"\n          }), _jsxs(\"article\", {\n            id: \"blockchainCrawlerDb\",\n            class: \"mt-2\",\n            children: [_jsxs(_components.h2, {\n              children: [_jsx(_components.a, {\n                href: \"#blockchainCrawlerDb\",\n                children: _jsx(\"img\", {\n                  src: \"hashtag.svg\",\n                  width: \"20px\",\n                  height: \"20px\"\n                })\n              }), \" Thiết kế database\"]\n            }), _jsx(_components.p, {\n              children: \"Sau đây là sơ đồ tổng quan về database của mình:\"\n            }), _jsxs(\"div\", {\n              class: \"mt-4\",\n              children: [_jsx(FullSizeImage, {\n                src: '/ducHuyHoangBlog/blockchain-crawler/db.png'\n              }), _jsx(\"div\", {\n                class: \"mt-2\",\n                children: _jsxs(_components.ul, {\n                  children: [\"\\n\", _jsxs(_components.li, {\n                    children: [\"\\n\", _jsxs(_components.p, {\n                      children: [_jsx(_components.code, {\n                        children: \"nft\"\n                      }), \": Lưu trữ nft\"]\n                    }), \"\\n\"]\n                  }), \"\\n\", _jsxs(_components.li, {\n                    children: [\"\\n\", _jsxs(_components.p, {\n                      children: [_jsx(_components.code, {\n                        children: \"collection\"\n                      }), \": Lưu collection của nft\"]\n                    }), \"\\n\"]\n                  }), \"\\n\", _jsxs(_components.li, {\n                    children: [\"\\n\", _jsxs(_components.p, {\n                      children: [_jsx(_components.code, {\n                        children: \"loans\"\n                      }), \": Lưu\\ntrạng thái và các hành động \", _jsx(_components.code, {\n                        children: \"lent\"\n                      }), \",\", _jsx(_components.code, {\n                        children: \"rent\"\n                      }), \" của nft tương ứng\"]\n                    }), \"\\n\"]\n                  }), \"\\n\", _jsxs(_components.li, {\n                    children: [\"\\n\", _jsxs(_components.p, {\n                      children: [_jsx(_components.code, {\n                        children: \"crawl_process\"\n                      }), \": Như mình đã nói trên kia ứng dụng của mình sẽ chạy interval worker để xử lý block mới trên 1 contract chỉ  vì vậy bảng này sẽ lưu lại block mới nhất mà đã được process.\"]\n                    }), \"\\n\"]\n                  }), \"\\n\", _jsxs(_components.li, {\n                    children: [\"\\n\", _jsxs(_components.p, {\n                      children: [_jsx(_components.code, {\n                        children: \"queue_logs\"\n                      }), \": Ứng dụng của mình sẽ không xử lý trực tiếp mà dùng queue pattern để xử lý data. Trước tiên push data nhận đc từ worker bất kì vào bảng queue_log kèm với queue_name tương ứng. Từ đó lấy data từ queue_log ứng và xử lý\"]\n                    }), \"\\n\"]\n                  }), \"\\n\"]\n                })\n              })]\n            })]\n          }), _jsxs(\"article\", {\n            id: \"blockchainTech\",\n            children: [_jsxs(_components.h2, {\n              children: [_jsx(_components.a, {\n                href: \"#blockchainTech\",\n                children: _jsx(\"img\", {\n                  src: \"hashtag.svg\",\n                  width: \"20px\",\n                  height: \"20px\"\n                })\n              }), \" Công nghệ sử dụng và các gói quan trọng\"]\n            }), _jsxs(_components.ul, {\n              children: [\"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"Typescript\"\n                })\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"Nodejs\"\n                })\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"Express\"\n                })\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"PostgreSQL\"\n                })\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"Redis\"\n                })\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"Moralis\"\n                })\n              }), \"\\n\", _jsxs(_components.li, {\n                children: [_jsx(_components.code, {\n                  children: \"bull\"\n                }), \" (gói quan trọng dùng cho Queue pattern)\"]\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"web3\"\n                })\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"ethers\"\n                })\n              }), \"\\n\", _jsx(_components.li, {\n                children: _jsx(_components.code, {\n                  children: \"typeorm\"\n                })\n              }), \"\\n\"]\n            })]\n          }), _jsxs(\"article\", {\n            id: \"blockchainCrawlerBaseClass\",\n            children: [_jsxs(\"section\", {\n              id: \"blockchainCrawlerIntervalWorker\",\n              children: [_jsxs(_components.h2, {\n                children: [_jsx(_components.a, {\n                  href: \"#blockchainCrawlerBaseClass\",\n                  children: _jsx(\"img\", {\n                    src: \"hashtag.svg\",\n                    width: \"20px\",\n                    height: \"20px\"\n                  })\n                }), \" Các base class trong ứng dụng\"]\n              }), _jsx(\"div\", {\n                class: \"ml-4\",\n                children: _jsxs(_components.h3, {\n                  children: [_jsx(_components.a, {\n                    href: \"#blockchainCrawlerIntervalWorker\",\n                    children: _jsx(\"img\", {\n                      src: \"hashtag.svg\",\n                      width: \"20px\",\n                      height: \"20px\"\n                    })\n                  }), \" BaseIntevalWorker\"]\n                })\n              }), _jsxs(_components.ul, {\n                children: [\"\\n\", _jsxs(_components.li, {\n                  children: [_jsx(_components.code, {\n                    children: \"BaseIntevalWorker\"\n                  }), \" : Một cái \\\"khuôn\\\" để thực hiện 1 action nhất định trong 1 khoảng thời gian. Phương thức \", _jsx(_components.code, {\n                    children: \"prepare\"\n                  }), \" và \", _jsx(_components.code, {\n                    children: \"doProcess\"\n                  }), \" sẽ được các lớp kế thừa lớp này viết vào thực hiện action nhất định\"]\n                }), \"\\n\"]\n              }), _jsx(_components.pre, {\n                filename: \"BaseIntevalWorker.ts\",\n                children: _jsx(_components.code, {\n                  className: \"language-ts\",\n                  children: \"export abstract class BaseIntervalWorker {\\n  private nextTickTime: number = 3000\\n  private processingTimeout: number = 6000\\n  private isStopped: boolean = false\\n\\n  public getProcessingTimeout() {\\n    return this.processingTimeout\\n  }\\n\\n  public getNextTickTime() {\\n    return this.nextTickTime\\n  }\\n\\n  public setNextTickTime(time: number) {\\n    this.nextTickTime = time\\n  }\\n\\n  public setProcessingTimeout(time: number) {\\n    this.processingTimeout = time\\n  }\\n  public stop() {\\n    this.isStopped = true\\n  }\\n\\n  public start(): void {\\n    this.prepare()\\n      .then(() => {\\n        this.onTick()\\n      })\\n      .catch(e => {\\n        console.log(e)\\n        console.log(`${this.constructor.name} prepare failed`)\\n      })\\n  }\\n\\n  private onTick() {\\n    if (this.isStopped) {\\n      return\\n    }\\n    const timer = setTimeout(() => {\\n      console.log(`${this.constructor.name} time out!`)\\n      process.exit(1)\\n    }, this.getProcessingTimeout())\\n    this.doProcess()\\n      .then(() => {\\n        if (this.isStopped) return\\n        clearTimeout(timer)\\n        setTimeout(() => {\\n          this.onTick()\\n        }, this.getNextTickTime())\\n      })\\n      .catch(e => {\\n        console.log(e)\\n        if (this.isStopped) return\\n        clearTimeout(timer)\\n        setTimeout(() => {\\n          this.onTick()\\n        }, this.getNextTickTime())\\n      })\\n  }\\n\\n  protected abstract prepare(): Promise<void>\\n  protected abstract doProcess(): Promise<void>\\n}\\n\"\n                })\n              }), _jsx(\"hr\", {\n                class: \"mb-4 mt-4\"\n              })]\n            }), _jsxs(\"section\", {\n              id: \"blockchainCrawlerEventCrawler\",\n              children: [_jsx(\"div\", {\n                class: \"ml-4\",\n                children: _jsxs(_components.h3, {\n                  children: [_jsx(_components.a, {\n                    href: \"#blockchainCrawlerEventCrawler\",\n                    children: _jsx(\"img\", {\n                      src: \"hashtag.svg\",\n                      width: \"20px\",\n                      height: \"20px\"\n                    })\n                  }), \" BaseEventCrawler\"]\n                })\n              }), _jsxs(_components.ul, {\n                children: [\"\\n\", _jsxs(_components.li, {\n                  children: [_jsx(_components.code, {\n                    children: \"BaseEventCrawler\"\n                  }), \": Một lớp base khác được kế thừa từ \", _jsx(_components.code, {\n                    children: \"BaseIntervalWorker\"\n                  }), \" chịu trách nhiệm đọc những block mới nhất từ đó truyền data đọc được qua phương thức abstract \", _jsx(_components.code, {\n                    children: \"handleCrawledEvents\"\n                  }), \" từ đó các lớp khác kế thừa lớp này sẽ kế thừa và tùy biến thực hiện action với data crawl được\"]\n                }), \"\\n\"]\n              }), _jsx(_components.pre, {\n                filename: \"BaseEventCrawler.ts\",\n                children: _jsx(_components.code, {\n                  className: \"language-ts\",\n                  children: \"import { BaseIntervalWorker } from './BaseIntervalWorker'\\nimport Web3 from 'web3'\\nimport dataSource from '../../configs/dataSource'\\nimport CrawlProcess from '../../entities/CrawlProcess'\\nimport { Interface, JsonRpcProvider } from 'ethers'\\nimport { DEFAULT_BREAK_TIME_AFTER_ONE_GO } from '../../common/constant'\\nimport { NETWORK } from '../../common/enum'\\nexport interface IEventCrawler {\\n  networkConfigs: {\\n    contract: {\\n      contractName: string\\n      contractAddress: string\\n      contractAbi: any\\n    }\\n\\n    rpcUrl: string\\n    network: NETWORK\\n    blockPerOneGo: number\\n    averageBlockTime: number\\n    latestFromNetwork: boolean\\n    confirmationBlock: number\\n    latestBlock?: number\\n  }\\n}\\n\\nabstract class BaseEventCrawler<R> extends BaseIntervalWorker {\\n  private LATEST_BLOCK_FROM_NETWORK: number = NaN\\n  private LATEST_PROCESSED_BLOCK: number = NaN\\n  private crawlProcess: CrawlProcess\\n  constructor(protected options: IEventCrawler) {\\n    super()\\n  }\\n\\n  protected abstract handleCrawledEvents(datas: Array<R>): Promise<void>\\n\\n  protected async processBlock({\\n    fromBlock,\\n    toBlock,\\n    latestNetworkBlock\\n  }: {\\n    fromBlock: number\\n    toBlock: number\\n    latestNetworkBlock: number\\n  }) {\\n    const web3 = new Web3(this.getNetworkConfigs().rpcUrl)\\n    const contract = new web3.eth.Contract(\\n      this.getContractConfigs().contractAbi,\\n      this.getContractConfigs().contractAddress\\n    )\\n    console.log(\\n      `Begin process from ${fromBlock} to ${toBlock} / Latest network block: ${latestNetworkBlock}`\\n    )\\n\\n    const eventLogs = await contract.getPastEvents(\\n      'allEvents',\\n      {\\n        fromBlock,\\n        toBlock\\n      },\\n      (err: any) => {\\n        !!err && console.log('Crawl event from sc:', err)\\n      }\\n    )\\n    // console.log(\\\"total crawled data:\\\", eventLogs);\\n    const formattedEventLogs = eventLogs\\n\\n    await this.handleCrawledEvents(\\n      formattedEventLogs\\n        .sort((a, b) => a.blockNumber - b.blockNumber)\\n        .map(\\n          event =>\\n            ({\\n              event: event.event,\\n              data: event.returnValues,\\n              blockNumber: event.blockNumber\\n            } as R)\\n        )\\n    )\\n  }\\n\\n  protected getNetworkConfigs() {\\n    this.getBlockData\\n    return this.options.networkConfigs\\n  }\\n  protected getContractConfigs() {\\n    return this.options.networkConfigs.contract\\n  }\\n  protected getCurLatestProcessedBlock() {\\n    return parseInt(this.LATEST_PROCESSED_BLOCK.toString(), 10)\\n  }\\n\\n  protected async doProcess() {\\n    if (!this.crawlProcess) {\\n      console.log(`No crawling process found for : ${this.constructor.name}`)\\n      return\\n    }\\n    const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()\\n\\n    this.LATEST_BLOCK_FROM_NETWORK = latestBlockFromNetwork\\n\\n    this.LATEST_PROCESSED_BLOCK = this.crawlProcess.lastProcessedBlock\\n\\n    let latestProcessedBlock = this.getCurLatestProcessedBlock()\\n\\n    const fromBlockNumber =\\n      latestProcessedBlock === 0 ? 0 : latestProcessedBlock + 1\\n\\n    if (fromBlockNumber > latestBlockFromNetwork) {\\n      console.log(`Block ${fromBlockNumber} is the newest block`)\\n      return\\n    }\\n\\n    let toBlockNumber = fromBlockNumber + this.getNetworkConfigs().blockPerOneGo\\n    if (toBlockNumber > latestBlockFromNetwork) {\\n      console.log('To block is higher')\\n      toBlockNumber = latestBlockFromNetwork\\n    }\\n\\n    console.log(\\n      `FROM ${fromBlockNumber} TO ${toBlockNumber} LATEST ${latestBlockFromNetwork}`\\n    )\\n\\n    await this.processBlock({\\n      fromBlock: fromBlockNumber,\\n      toBlock: toBlockNumber,\\n      latestNetworkBlock: latestBlockFromNetwork\\n    })\\n\\n    const crawlProcessRepository = dataSource.getRepository(CrawlProcess)\\n    this.crawlProcess.lastProcessedBlock = toBlockNumber\\n    await crawlProcessRepository.save(this.crawlProcess)\\n\\n    this.LATEST_PROCESSED_BLOCK = toBlockNumber\\n\\n    // Have processed latest network block so set next tick time by average time\\n    if (fromBlockNumber === toBlockNumber) {\\n      this.setNextTickTime(this.getNetworkConfigs().averageBlockTime)\\n    } else {\\n      this.setNextTickTime(DEFAULT_BREAK_TIME_AFTER_ONE_GO)\\n    }\\n  }\\n\\n  public async getBlockData(block_number: string | number) {\\n    const web3 = new Web3(this.getNetworkConfigs().rpcUrl)\\n    return web3.eth.getBlock(block_number)\\n  }\\n\\n  public async getTransactionData(block_number: string | number) {\\n    const jsonProvider = new JsonRpcProvider(this.getNetworkConfigs().rpcUrl)\\n    const inter = new Interface(this.getContractConfigs().contractAbi)\\n    const blockData = await this.getBlockData(block_number)\\n\\n    const datas = await Promise.all(\\n      blockData.transactions.map(async transaction => {\\n        const tx = await jsonProvider.getTransaction(transaction)\\n        if (tx?.data) {\\n          const decodedOutput = inter.parseTransaction({\\n            data: tx.data,\\n            value: tx.value\\n          })\\n          return decodedOutput\\n        }\\n        return null\\n      })\\n    )\\n    return datas.filter(data => !!data)\\n  }\\n\\n  protected async getNetworkLatestBlockNumber() {\\n    const web3 = new Web3(this.getNetworkConfigs().rpcUrl)\\n    const latestBlockFromNetwork = await web3.eth.getBlockNumber()\\n    console.log(\\n      'network',\\n      latestBlockFromNetwork,\\n      'real:',\\n      latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock\\n    )\\n    return latestBlockFromNetwork - this.getNetworkConfigs().confirmationBlock\\n  }\\n\\n  protected async prepare() {\\n    const crawlProcessRepository = dataSource.getRepository(CrawlProcess)\\n    const latestBlockFromNetwork = await this.getNetworkLatestBlockNumber()\\n\\n    let crawlerProcess = await crawlProcessRepository\\n      .createQueryBuilder('CrawlProcess')\\n      .where({\\n        contractAddress: this.getContractConfigs().contractAddress\\n      })\\n      .andWhere({\\n        contractName: this.getContractConfigs().contractName\\n      })\\n      .getOne()\\n\\n    if (!crawlerProcess) {\\n      const newCrawlProcess = new CrawlProcess()\\n      newCrawlProcess.contractAddress =\\n        this.getContractConfigs().contractAddress\\n      newCrawlProcess.contractName = this.getContractConfigs().contractName\\n      newCrawlProcess.lastProcessedBlock = this.getNetworkConfigs()\\n        .latestFromNetwork\\n        ? latestBlockFromNetwork === 0\\n          ? 0\\n          : latestBlockFromNetwork - 1\\n        : (this.getNetworkConfigs().latestBlock || 0) - 1\\n      try {\\n        this.crawlProcess = await crawlProcessRepository.save(newCrawlProcess)\\n      } catch (e: any) {\\n        console.log(`Error while insert new crawling process: ${e.message}`)\\n      }\\n    } else {\\n      const crawlProcessRepository = dataSource.getRepository(CrawlProcess)\\n      crawlerProcess.lastProcessedBlock = this.getNetworkConfigs()\\n        .latestFromNetwork\\n        ? latestBlockFromNetwork === 0\\n          ? 0\\n          : latestBlockFromNetwork - 1\\n        : (this.getNetworkConfigs().latestBlock || 0) - 1\\n      await crawlProcessRepository.save(crawlerProcess)\\n\\n      this.crawlProcess = crawlerProcess\\n    }\\n  }\\n}\\n\\nexport default BaseEventCrawler\\n\"\n                })\n              }), _jsxs(_components.ul, {\n                children: [\"\\n\", _jsxs(_components.li, {\n                  children: [\"Các configs số của lớp:\", \"\\n\", _jsxs(_components.ul, {\n                    children: [\"\\n\", _jsxs(_components.li, {\n                      children: [_jsx(_components.code, {\n                        children: \"contract\"\n                      }), \": Thông tin của contract\"]\n                    }), \"\\n\", _jsxs(_components.li, {\n                      children: [_jsx(_components.code, {\n                        children: \"rpcUrl\"\n                      }), \": RPC url của mạng\"]\n                    }), \"\\n\", _jsxs(_components.li, {\n                      children: [_jsx(_components.code, {\n                        children: \"blockPerOneGo\"\n                      }), \": Thông tin của contract của mạng Số lương block mà 1 lần chạy sẽ lấy (số lượng nên là \", _jsx(_components.code, {\n                        children: \"200\"\n                      }), \" vì hàm \", _jsx(_components.code, {\n                        children: \"getPastEvents\"\n                      }), \" của \", _jsx(_components.code, {\n                        children: \"web3\"\n                      }), \" bị giới hạn số lượng trả về)\"]\n                    }), \"\\n\", _jsxs(_components.li, {\n                      children: [_jsx(_components.code, {\n                        children: \"averageBlockTime\"\n                      }), \" : Thời gian trung bình để mạng sinh ra 1 block mới\"]\n                    }), \"\\n\", _jsxs(_components.li, {\n                      children: [_jsx(_components.code, {\n                        children: \"latestFromNetwork\"\n                      }), \": Nếu option này là \", _jsx(_components.code, {\n                        children: \"true\"\n                      }), \" thì worker sẽ luôn crawl block mới nhất trên mạng và option \", _jsx(_components.code, {\n                        children: \"latestBlock\"\n                      }), \" sẽ không có tác dụng\"]\n                    }), \"\\n\", _jsxs(_components.li, {\n                      children: [_jsx(_components.code, {\n                        children: \"confirmationBlock\"\n                      }), \": Số lượng block mà mạng cần có để trừ đi với latest block trên mạng để chắc chắn rằng transaction trong 1 block không bị reverse\"]\n                    }), \"\\n\", _jsxs(_components.li, {\n                      children: [_jsx(_components.code, {\n                        children: \"latestBlock\"\n                      }), \": Số thứ tự block mà worker sẽ bắt đầu crawl (Nếu \", _jsx(_components.code, {\n                        children: \"latestFromNetwork\"\n                      }), \" =  \", _jsx(_components.code, {\n                        children: \"true\"\n                      }), \" thì option này không có tác dụng)\"]\n                    }), \"\\n\"]\n                  }), \"\\n\"]\n                }), \"\\n\"]\n              }), _jsx(\"hr\", {\n                class: \"mb-4 mt-4\"\n              })]\n            }), _jsxs(\"section\", {\n              id: \"blockchainCrawlerProcessor\",\n              children: [_jsx(\"div\", {\n                class: \"ml-4\",\n                children: _jsxs(_components.h3, {\n                  children: [_jsx(_components.a, {\n                    href: \"#blockchainCrawlerProcessor\",\n                    children: _jsx(\"img\", {\n                      src: \"hashtag.svg\",\n                      width: \"20px\",\n                      height: \"20px\"\n                    })\n                  }), \" Processor\"]\n                })\n              }), _jsxs(_components.ul, {\n                children: [\"\\n\", _jsxs(_components.li, {\n                  children: [_jsx(_components.code, {\n                    children: \"Processor\"\n                  }), \": Như mình nói ở trên khi các crawler worker crawl được event từ block mới thì sẽ push vào bảng \", _jsx(_components.code, {\n                    children: \"queue_logs\"\n                  }), \" từ đó lấy data ra và xử lý. Lớp \", _jsx(_components.code, {\n                    children: \"Processor\"\n                  }), \" được kế thừa từ \", _jsx(_components.code, {\n                    children: \"BaseIntervalWorker\"\n                  }), \" sẽ làm nhiệm vụ lấy data 1 trong một khoảng thời gian. Lớp con cần kế thừa phương thức \", _jsx(_components.code, {\n                    children: \"handleUnfinishedOrFailedTask\"\n                  }), \" để xử lý những task được lấy từ databse.\"]\n                }), \"\\n\"]\n              }), _jsx(_components.pre, {\n                filename: \"Processor.ts\",\n                children: _jsx(_components.code, {\n                  className: \"language-ts\",\n                  children: \"import { Queue } from 'bull'\\nimport { EntityManager } from 'typeorm'\\nimport QueueManagement from '..'\\nimport { QUEUE_NAMES } from '../../common/constant'\\nimport { QueueStatus } from '../../common/enum'\\nimport { dateInMiliseconds } from '../../common/utils'\\nimport dataSource from '../../configs/dataSource'\\nimport QueueLog from '../../entities/QueueLog'\\nimport { BaseIntervalWorker } from '../../fetcher/base/BaseIntervalWorker'\\nimport { queueLogRepository } from '../../repository'\\n\\ninterface IProcessor {\\n  concurrency?: number\\n  queue_name: string\\n}\\n\\nabstract class Processor extends BaseIntervalWorker {\\n  protected queueInstance: Queue\\n  protected concurrency: number = 1\\n  constructor(private queueName: QueueName) {\\n    super()\\n    this.queueInstance = QueueManagement.get(this.queueName)!\\n  }\\n\\n  public setConcurrency(value: number) {\\n    this.concurrency = value\\n  }\\n\\n  public getConcurrency() {\\n    return this.concurrency\\n  }\\n\\n  protected abstract handleUnfinishedOrFailedTask(\\n    manager: EntityManager,\\n    listTask: Array<QueueLog>\\n  ): Promise<void>\\n\\n  protected async doProcess(): Promise<void> {\\n    dataSource.transaction(async (manager: EntityManager) => {\\n      const listQueueLogs = await manager\\n        .getRepository(QueueLog)\\n        .createQueryBuilder('queue_logs')\\n        .orderBy('retry_at', 'ASC')\\n        .where(\\n          'queue_name = :queue_name AND try_num < 3 AND retry_at < :now AND retry_at IS NOT NULL AND status <> :status',\\n          {\\n            now: dateInMiliseconds(),\\n            status: QueueStatus.COMPLETE,\\n            queue_name: this.queueName\\n          }\\n        )\\n        .take(this.getConcurrency())\\n        .getMany()\\n\\n      await this.handleUnfinishedOrFailedTask(manager, listQueueLogs)\\n    })\\n  }\\n}\\n\\nexport default Processor\\n\"\n                })\n              }), _jsx(\"hr\", {\n                class: \"mb-4 mt-4\"\n              })]\n            }), _jsxs(\"section\", {\n              id: \"blockchainLauncher\",\n              children: [_jsx(\"div\", {\n                class: \"ml-4\",\n                children: _jsxs(_components.h3, {\n                  children: [_jsx(_components.a, {\n                    href: \"#blockchainLauncher\",\n                    children: _jsx(\"img\", {\n                      src: \"hashtag.svg\",\n                      width: \"20px\",\n                      height: \"20px\"\n                    })\n                  }), \" BaseLauncher\"]\n                })\n              }), _jsxs(_components.ul, {\n                children: [\"\\n\", _jsxs(_components.li, {\n                  children: [\"Và cuối cùng là lớp \", _jsx(_components.code, {\n                    children: \"BaseLauncher\"\n                  }), \" dùng để start các worker theo ý của người viết. Các lớp con cần kế thừa phương thức \", _jsx(_components.code, {\n                    children: \"prepare\"\n                  }), \" và \", _jsx(_components.code, {\n                    children: \"handleStart\"\n                  }), \" để thực hiện logic.\"]\n                }), \"\\n\"]\n              }), _jsx(_components.pre, {\n                filename: \"Processor.ts\",\n                children: _jsx(_components.code, {\n                  className: \"language-ts\",\n                  children: \"  import { wrapperAsync } from '../../common/utils'\\n\\n  export default abstract class BaseLauncher {\\n    constructor() {}\\n    protected abstract prepare(): Promise<void>\\n    protected abstract handleStart(): Promise<void>\\n    public async start() {\\n      const [_, prepareError] = await wrapperAsync(this.prepare())\\n      if (prepareError) {\\n        console.log(`${this.constructor.name} cannot prepare`)\\n        return\\n      }\\n\\n      const [startRs, startError] = await wrapperAsync(this.handleStart())\\n\\n      if (startError) {\\n        console.log(`${this.constructor.name} running failed`)\\n        return false\\n      } else {\\n        console.log(`${this.constructor.name} running succeed`)\\n        return true\\n      }\\n    }\\n  }\\n\"\n                })\n              }), _jsx(_components.hr, {})]\n            })]\n          })]\n        })\n      }), \"\\n\", _jsxs(\"div\", {\n        id: \"blockchainCrawlerSummary\",\n        class: \"mt-4\",\n        children: [_jsxs(_components.h2, {\n          children: [_jsx(_components.a, {\n            href: \"#blockchainCrawlerSummary\",\n            children: _jsx(\"img\", {\n              src: \"hashtag.svg\",\n              width: \"20px\",\n              height: \"20px\"\n            })\n          }), \" Tổng kết\"]\n        }), _jsx(_components.p, {\n          children: \"Như vậy là mình đã giới thiệu cho các bạn về phần 1 về 1 con crawler blockchain rồi. Hẹn các bạn phần sau để implement các lớp base mà hôm nay mình đã giới thiệu các bạn nhé\"\n        })]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"fileMetadata":{"slug":"voc-vach-code-thu-1-con-crawler-blockchain-phan-1","title":"Vọc vạch code thử 1 crawler event trên mạng blockchain phần 1","date":"04/04/2023","image":"blockchain-crawler/bg.jpeg","author":{"name":"Đức Huy Hoàng","avatar":"selfAvatar.jpg"},"description":"Bài viết hướng dẫn chi tiết về 1 chương trình ví dụ crawler event của blockchain","tags":["Tech","Blockchain","Backend","Nodejs","SelfTaught"],"isFeature":true,"minuteRead":20},"compliedSource":""},"__N_SSG":true}